# Kotlin coroutines 
#android/async

[Примеры](practice/Coroutines)  
[Зависимости](Dependencies)  

## Suspend-функции
<span style = "color: #008ffd">suspend - функция</span> - функция которая может приостанавливать своё выполнение. Что это значит и как работает. Когда начинается выполнение такой функции, она занимает главный поток.  

**Назначение:**  
		- запуск асинхронного кода;  
		- написание асинхронного кода в синхронном стиле;  
		- не блокирует главный поток  

**Приемущества:**
		- легковесные - занимают мало ресурсов  
		- эффективные - т.к. приостанавливают выполнение ф-ии и не занимают поток ожиданием результата  
		- позволяют избежать утечек памяти - за счёт привязки корутины к определённому ЖЦ компонента  
		- простота отмены  
		- позволяют обрабатывать ошибки  
		- интегрированны с компонентами jetpack  


```kotlin
	suspend fun fetchDocs()) {
		val docs = get("_")
		show(docs)
	}
```

- *fetchDocs()* - suspend funtion которая вызывается на главном потоке, всё что она делаен - получает документы и показывает их. После её вызова, она добавляется в стек вызова
- *get()* - выполняется на фоновом потоке, получение документов происходит из сети интернет. После вызова, так же добавляется в стэк. После его вызова он начинает работу в фоновом потоке. Данный метод также является suspend функцией
- Основная ф-ия fetchDocs() приостановила своё выполнение после чего была снята  со стекаа вызова главного потока как и метод get(). Главный поток стал своболдным. При этом информация о вызове и точке приостанова была сохранена( Где сохранена? Кем сохранена? #question)
- После того как метод get() будет выполнен, произойдёт возобновление ф-ии fetchDocs(). В стэк главного потока вновь поместится её вызов. При этом fetchDocs() продолжет выполнение именно с того места, где остановила свою работу

## Coroutine Builder
**Назначение:**  
		- запуск корутины  

**Виды:**  
		- *runBlocking* - запускает корутину в текущем потоке блокируя его  
		- *launch* - запуск корутины на выполнение  
		- *async* - запуск корутины и получение результата  

При написании корутин используется подход Structured concurrency:
* кто может отменить выполнение корутины
* привязано ли выполнение корутины к ЖЦ
* как обрабатываются ошибки внутри корутины
* как корутины взаимодействуют с дочерними или родительскими корутинами

## Coroutine Scope
**Назначение:**  
		- позволяет отслеживать выполняемые в нём корутины  
		- может содержать в себе разное количество корутин  
		- позволяет отменить выполнение всех корутин внутри него одновременно  
		- оповещается при возникновении ошибки внутри корутины  

**GlobalScope** - глобальный scope который лучше не использовать т.к. его нельзя контролировать не возможно:

-   определить поток на котором будут запускаться корутины
-   определять поведение при ошибках,
-   отменять корутины

К нему можно получить доступ из любой точки програмы что не хорошо с точки зрения инкапсуляции.

Лучше создавать свой scope c использованием функции (да-да это функция) CoroutineScope() которая принимает на вход один из диспетчеров.

Для запуска корутин используется Coroutine scope, внутри которого тоже используются job-ы.

```kotlin
class Fragment {
	private val fragmentScope = CoroutineScope(Dispatchers.Main)

	override fun onResume() {
		super.onResume()
		fragmentScope.launch {}
		fragmentScope.launch {}
	}

	override fun onDestroy() {
		super.onDestroy()
		fragmentScope.cancel()
	}
}
```

Приемущество scope в том что если мы например задаём несколько корутин внутри одного scope у нас будет использоваться 1 и тот же диспетчер для всех корутин.

Так же все корутины можно будет отменить разом, вызвав на scope метод cancel()

**CoroutineScope** - интерфейс инстанс которого хранит внутри себя coroutineContext - map(key, value). Из контекста при работе корутин можно доставлять значения которые лежат в этой мапе. Внутри coroutineContext находится Job, Dispatcher, ErrorHandler. Так же туда можно положить любые собственные объекты, которые наследубтся от класса CoroutinContextElement. Это нужно для того, чтобы эти объекты были доступны из нескольких корутин.

Для создания CoroutineScope необходимо передать Job иначе он создастся автоматически.
```kotlin
public interface CoroutineScope {
	public val coroutineContext: CoroutineContext

}
```
CoroutineContext содержит:
- Job
- Dispatcher
- CoroutineExceptionHandler
- объект, имплементирующий CoroutineContext.Element

```kotlin
private val fragmentScope = CoroutineScope(Job())

public fun CoroutineScope(context: CoroutineContext): CoroutineScope =
	CoroutineScope(if(context[Job] != null) context elese context + Job())
```

Job у Scope работает аналогично Job-у родительской корутины. Когда вы запускаете корутину в скопе вы создаёте дочерний Job для главного Job-а. Когда главный Job будет отменён, все дочерние так же будут отменены.

scope job <-- coroutine job <-- child coroutine job

```kotlin
public fun CoroutineScope.cnacel(cause: CancellationException? = null) {
	val job = coroutineContext[Job] ?: error("Scope does not have a job $this")
}
```
Т.е. в методе scope.cancel() мы обращаемся к coroutineContext получаем из него Job и вызываем метод job.cancel() что отменяет за собой все дочерние корутины.

```kotlin
val coroutineContext = Dispatchers.Main
val fragmentScope = CoroutineScope(coroutineContext)

//sum context
val coroutineContext = Job() + Dispatchers.Main
val fragmentScope = CoroutineScope(coroutineContext)
```

При создании scope часто указывается не только Job но и Dispatchers, чтобы указать поток по умолчанию в котором будет выполняться корутина. Есть 2 пути:

1.  Указать Dispatcher при создании CoroutineScope, в этом случае DIspatcher находится внутри контекста и поэтому является контекстом
2.  Либо можно объединить два контекста в один с помощью оператора +

В простом случае не имеет смысла создавать Job вручную, т.к. он будет создан автоматически под капотом.

В контексте всегда присутствует Job и может присутствовать или нет Диспетчер и обработчик ошибок.

Job присутствует всегда для того чтобы можно было связать выполнение дочерних корутин со scope.

## Dispatchers
**Диспетчер** - сущность которая запускает код на определённом потоке или пуле потоков.
-   **Dispatchers.Main** - выполняет задачи на главном потоке на главном потоке. Главный поток получается из зависимостей UI которые нужно подключать явно т.к. корутины не привязаны к платформе. У каждой платформы имеется свой главный поток (*implementation "org.jetbrains.kotlin:kotlin-coroutines android:$coroutinesVersion"*)
-   **Dispatchers.Default** - выполняет задачи на пуле потоков. Размер пула зависит от кол-ва ядер процессора. Исп. для ресурсоёмких задач, чтобы минимизировать переключение м/у потоками
-   **Dispatchers.IO** - выполняет задачи ввода-вывода (работа с сетью, файловой системой) max pool size = 64
-   **Dispatchers.Unconfined** - не переключается м/у потоками. Продолжает выполнять код на том же потоке на котором он выполнялся
-   **Dispatchers.Custom** - собственный диспетчер потоков

Если диспетчер выполняет код на пуле потоков, то при возобновлении работы suspend-функции, код может продолжить работу на другом потоке

## Continuation
Android имеет виртуальную машину, которая ничего не знает о suspend функциях и о корутинах. Поэтому при переводе в байткод, компилятор избавляется от suspend функций и приобразовывает код в оптимизированную версию callback с использованием satae machine. В этом ему помогает интерфейс Continuation.

**Continuation** - интерфейс который позволяет продолжить выполнение после точки приостановки. Интерфейс имеет внутри себя контекст корутины и метод resume который позволяет продолжить выполнение приостановленной ф-ии
```kotlin
public interface Continuation<in T> {
	public val context: CoroutineContext
	public fun resumeWith(result: Result<T>)
}
```

При компиляции, наша suspend function которая передаётся для выполнения в корутину, преобразуется в объект класса Continuation который имеет метод invokeSuspend(...) внутри этого метода описана основная логика работы.
Код
```kotlin
scope.launch {
	showLoading(true)
	makeAction()
	showLoading(false)
}
```
будет преобразована в
```java
class GeneratedContinuation extends Continuation<Any?> {
	void invokeSuspend(...) {
		makeAction()
		showLoading(false)
	}
}
```
Код корутины преобразуется в конечный автомат или state machine.

State machine - набор состояний и определённые переходы, которые связывают эти состояния м/у собой.

Перейти из одного состояния в другое можно только по переходу.

Код который нужно выполнить в suspend функции разбивается на несколько состояний, в соответствии с точками приостановки.

Например в нашей ф-ии точка приостановки только одна - метод makeAction(), поэтому у state machine будет 2 состояния.

При поподании в 1ое состояние выполнится весь код до точки приостановки. При поподании во 2ое - весь остальной код после точки приостановки.
![[Pasted image 20220903114952.png]]

Для определения состояния state machine вводится поле label. По умолчанию label = 0. При запуске корутины мы поподаем в 1-ое состояние

1.  Когда корутина запускается, у Continuation вызывается метод invokeSuspend() в котором проверяется в каком состоянии находится suspend ф-ия
2.  В зависимости от текущего состояния label будет вызван кусок кода в блоке case (см рисунок.). Перед тем как вызвать suspend функцию, устанавливается след. состояние в которое нужно будет перейти после окончания вызова suspend ф-ии.
3.  После этого вызывается suspend ф-ия makeAction() и выполнение текущей ф-ии приостанавливается. Главный поток освобождается.
4.  После того как заканчивается асинхронный вызов у Continuation, который пришёл из вне, вызывается метод resume(), который внутри себя вызовет метод invokeSuspend() родительской suspend - функции. Т.е это выглядит как обычный callback.
5.  После того, как был вызван метод onResume() у completion в методе makeAction(), запускается заново метод invokrSuspend() родительской suspend ф-ии, в которой выполняется блок кода который соответствует состоянию 1, который будет выполнен на главном потоке.


Suspend ф-ия makeAction() принимает на вход Continuation, который передаётся в качестве параметра this который добавляет компилятор. И внутри себя создаёт новый Continuation который хранит состояние ф-ии makeAction()

![[Pasted image 20220903115352.png]]

**Рассмотрим пример когда suspend ф-ия возвращает какое либо значение.**
![[Pasted image 20220903115733.png|500]]
![[Pasted image 20220903115853.png]]
Для того чтобы работать с результатом ф-ии метод invokeSuspend() у Continuation принимает параметр reslult типа Object.

До того как ф-я donloadItems() не закончит своё выполнение работа ф-ии аналогична тому, что рассматривалось ранее.

В тот момент когда downloadItems() хочет вернуть результат, она вызывает Continuation родительской ф-ии и вызывает метод resume с параметром результата.

Т.е. ф-ия downloadItems() ничего не возвращает. Результат возвращается через Continuation.

После вызова resume с результатом, будет вызван метод invokeSuspend() и туда передастся на вход параметр result.

В ветке switch 1 результат будет приведён к ожидаемому типу и с ним будут проведены дальнейшие действия.

Для того, чтобы можно было обрабатывать результаты от нескольких suspend функций параметр-результат в методе invokeSuspend() имеет тип Object а приведение к нужному типу происходит в зависимости от шага.

Результат сохраняется в поле Continuation которое генгерируется автоматически, чтобы на каком то из шагов можно было использовать результаты предыдущих вычислений например.

## Coroutine States
![[CoroutinesStates.svg]]
При своём выполнении корутина переходит м/у состояниями.

Каждая корутина имплементирует интерфейс Job - интерфейс, который определяет состояние корутины в определённый момент времени.

| **state**                       | **isActive** | **isCompleted** | **isCanceled** |
| ------------------------------- |:------------:|:---------------:|:--------------:|
| *New*(optional initial state)   |    false     |      false      |     false      |
| *Active*(default initial state) |     true     |      false      |     false      |
| *Completing*(transient state)   |     true     |      false      |     false      |
| *Cancelling*(transient state)   |    false     |      false      |      true      |
| *Canceled*(final state)         |    false     |      true       |      true      |
| *Completed*(final state)        |    false     |      true       |     false      |

Используя CoroutineBuilder можно получить инстанс джоба, с помощью него можно проверить состояние корутины, а так же отменить корутину.

```kotlin
val job = scope.launch{}

job.isCompleted
job.isActive
job.isCanceled
job.cancel()
job.join()
```

Одним из основных направлений Structured Cuncarency является взаимоотношение родительских и дочерних корутин.

![[ChildCoroutine.svg|500]]
Т.к. корутина имплементирует интерфейс Job, то взаимоотношения корутин, превращаются во взаимоотношения Job-ов

Когда родительская корутина отменяется, отменяются все её дочерние корутины. Но если отменяется дочерняя корутина, это не значит что отменяется родительская. Так же родительская корутина не может быть завершена, пока не завершены все её дочерние корутины. Когда дочерняя корутина завершается, она оповещает об этом родительскую.

## Обработка ошибок
   
Алгоритм работы корутины при возникновении исключения:

1. Continuation возвращает результат ошибки
2. Job корутины изменяет состояние на "Отменнённый" и оповещает родительский Job об этом
3. Родительский Job отменяет все дочерние корутины
4.  В CoroutineContext у scope проверяется наличие exception handler
5.  Если обработчик ошибок есть, у него вызывается метод обработки исключения, если нет - происходит вызов глобального обработчика, который в Android крашит приложение и выводит исключение в logcat